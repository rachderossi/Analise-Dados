---
title: iFood CRM Data Analyst Case
author: Raquel Rossi
date: "`r Sys.Date()`"
output: rmdformats::readthedown
code_folding: hide
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(warning = FALSE, message = FALSE) 

library(rmarkdown)
library(rmdformats)
library(ggplot2)
library(rfm)
library(dplyr)
library(pander)
library(sqldf)
library(tidyverse)
library(highcharter)
library(RColorBrewer)
library(caTools)
library(e1071)
library(caret)
```

# Objetivo

O objetivo da equipe é construir um modelo preditivo que irá produzir o maior lucro para o próxima campanha de marketing direto, prevista para o próximo mês. A nova campanha, visa vender um novo gadget para o banco de dados do cliente. Para construir o modelo, uma campanha piloto envolvendo 2.240 clientes foi realizada. Os clientes foram selecionados aleatoriamente e contatados por telefone sobre a aquisição do gadget. Durante os meses seguintes, os clientes que compraram o oferta foram devidamente rotuladas. A taxa de sucesso da campanha foi de 15%. O objetivo da equipe é desenvolver um modelo que preveja o comportamento do cliente e o aplique ao restante da base de clientes. Esperançosamente, o modelo permitirá que a empresa escolha os clientes com maior probabilidade de comprar a oferta, deixando de fora os não respondentes, tornando a próxima campanha altamente rentável. Além disso, além de maximizar o lucro da campanha, o CMO está interessado em compreensão para estudar as características dos clientes que estão dispostos a comprar o gadget.

- O conjunto de dados contém características sociodemográficas e firmográficas sobre 2.240 clientes que
foram contatados. Além disso, ele contém uma bandeira para os clientes que responderam à campanha, comprando o produto.

```{r, include=FALSE}
setwd("C:/Users/Administrador/Downloads/ifood-data-business-analyst-test-master") # Trocar o caminho
dados <- read.csv(file = 'ml_project1_data.csv')

summary(dados)
str(dados)
```

# Cálculo RFM

```{r}
# valor gasto nos produtos
dados$mont <- dados$MntFishProducts+dados$MntFruits+dados$MntGoldProds+
              dados$MntMeatProducts+dados$MntSweetProducts+dados$MntWines

# quantidade de compras
dados$num <- dados$NumCatalogPurchases+dados$NumDealsPurchases+
             dados$NumStorePurchases+dados$NumWebPurchases

customers_RFM = sqldf(
    "SELECT ID,
            MIN(Recency) AS 'Recência',
            Sum(num) AS 'Frequência',
            SUM(mont) AS 'Monetariedade'
        FROM dados
        GROUP BY 1"
)

customers_RFM %>% 
  head(10) %>% 
      formattable::formattable()
```

# Histogramas

Para avaliar a distribuição dos parâmetros RFM podemos usar o histograma.

```{r}
# Recencia
ggplot(customers_RFM, aes(x = Recência)) +
        geom_histogram(aes(fill = ..count..), binwidth = 10) +
        scale_x_continuous(name = "Recência",
                           breaks = seq(0, 100, 10),
                           limits=c(0, 100)) +
        scale_y_continuous(name = "Count") +
        scale_fill_gradient(low="blue", high="red") + 
        ggtitle("Frequência da quantidade de tempo desde a última compra")

# Frequencia
ggplot(customers_RFM, aes(x = Frequência)) +
        geom_histogram(aes(fill = ..count..), binwidth = 5) +
        scale_x_continuous(name = "Frequência",
                           breaks = seq(0, 40, 5),
                           limits=c(0, 40)) +
        scale_y_continuous(name = "Count") +
        scale_fill_gradient(low="blue", high="red") + 
        ggtitle("Frequência da quantidade de compras feitas pelo cliente na empresa")

# Monetariedade
ggplot(customers_RFM, aes(x = Monetariedade)) +
        geom_histogram(aes(fill = ..count..), binwidth = 100) +
        scale_x_continuous(name = "Monetariedade",
                           breaks = seq(0, 2500, 500),
                           limits=c(0, 2500)) +
        scale_y_continuous(name = "Count") +
        scale_fill_gradient(low="blue", high="red") + 
        ggtitle("Frequência da quantidade de valor gasto pelo cliente na empresa")
```

# Percentil

```{r}
quantile(customers_RFM$Recência, probs = seq(0, 1, 0.20)) %>% pander()
```

Analisando a quantos dias foi a última compra do cliente, podemos observar que:

- Os Top20 clientes compraram nos últimos 19 dias;
- Os próximos 20% de clientes compraram no intervalo entre 19 e 39 dias;
- Ao passo que os últimos 20% de clientes ficam mais de 79 dias sem efetuar nenhuma compra.

```{r}
quantile(customers_RFM$Frequência, probs = seq(0, 1, 0.20)) %>% pander()
```

Quanto à frequência com que fazem as compras, podemos observar que:

- Os clientes Top20 compraram mais de 22 vezes ao longo do periódo em análise;
- Os seguintes 20% dos clientes compraram entre 17 e 22 vezes;
- Os últimos 20% dos clientes compraram 7 vezes no periódo em análise.

```{r}
quantile(customers_RFM$Monetariedade, probs = seq(0, 1, 0.20)) %>% pander()
```

Quanto ao valor gasto pelo cliente, podemos observar que:

- Os clientes Top20 gastam em média mais de 1174.00 u.m (unidade monetária);
- Os 20% seguintes gastam entre 635.4 e 1174.00 u.m, enquanto que os últimos 20% dos clientes gastam menos de 55.00 u.m em seu consumo médio.

# RFM score

```{r}
rfm_data <- customers_RFM

rfm_data <-
    rfm_data %>%
    mutate(
        R = ntile(desc(Recência), 5),
        F = ntile(Frequência, 5),
        M = ntile(Monetariedade, 5)
    )

rfm_data$RFM <- rfm_data$R * 100 + rfm_data$F * 10 + rfm_data$M

rfm_data %>% 
  head(10) %>% 
      formattable::formattable()
```

Note que, os clientes com elevado RFM score apresentam valores baixos para variável Recência e a altos para as variáveis Frequência e Monetariedade, por exemplo ID = 25, enquanto que os clientes com baixo RFM score, mostram altos valores para a variável Recência e altos para Frequência , como por exemplo ID = 17. Sendo que, para clientes com valores RFM score intermédios precisam de uma análise mais cuidadosa. Como será verificado a seguir.

# Segmentação de clientes

```{r}
rfm_data$segment <- NA

rfm_data$segment[which(rfm_data$RFM == 111)] <- 'Perdidos'
rfm_data$segment[which(rfm_data$RFM > 111)] <- 'Hibernando'

rfm_data$segment[which(rfm_data$RFM >= 222)] <- 'Prestes a hibernar'

rfm_data$segment[which(rfm_data$RFM >= 333)] <- 'Clientes em potencial'

rfm_data$segment[which(rfm_data$RFM >= 444)] <- 'Campeões'


# 2nd round
rfm_data$segment[which(rfm_data$segment == 'Clientes em potencial' &
                           (rfm_data$F >= 4))] <- 'Clientes fiéis'

rfm_data$segment[which(rfm_data$segment == 'Prestes a hibernar' &
                           (rfm_data$M >= 4))] <-'Precisa de atenção'

rfm_data$segment[which(rfm_data$segment == 'Hibernando' &
                           (rfm_data$F >= 4 & rfm_data$M >= 4))] <-'Não posso perdê-los'

rfm_data[, -c(5, 6,7)] %>% 
    head(10) %>% 
    formattable::formattable()
```

# Distribuição dos clientes por segmentos

```{r}
rfm_data$segment <-
    factor(
        x = rfm_data$segment,
        levels = c(
            'Perdidos',
            'Hibernando',
            'Não posso perdê-los',
            'Prestes a hibernar',
            'Precisa de atenção',
            'Novos clientes',
            'Clientes em potencial',
            'Clientes fiéis',
            'Campeões'
        )
    )


# tabela frequencia
freqTable <-
    rfm_data %>%
    # group_by(group) %>%
    count(segment) %>%
    # arrange(desc(n)) %>%
    rename(Segment = segment, Count = n)

freqTable %>% 
      formattable::formattable()


# ou agrupados
cust_aggr_dat <-
    aggregate(x = rfm_data[, 2:4],
              by = list(rfm_data$segment),
              mean)


cust_aggr_dat %>% 
      formattable::formattable()
```

Os resultados mostram que:

- Os clientes Campeões (598), considerados os clientes mais valiosos gastam em média o valor de 743.00 u.m, efetuaram compras por mais de 17 vezes e a última compra foi em média há 14 dias;
- Enquanto que, os Perdidos o caso pior estão há  88 dias sem efetuar uma compra;
- O destaque vai para o segmento Precisa de atenção, uma vez que apresentam um consumo elevado, contudo a última atividade foi há mais de 2 meses.

# Visualização dos dados

```{r}
# tree map
hctreemap2(
    data = freqTable,
    group_vars = "Segment",
    size_var = "Count",
    color_var = "Count"
    )

# grafico de barras
highchart() %>%
    hc_add_series(
        data = freqTable,
        type = 'column',
        hcaes(x = Segment, y = Count),
        dataLabels = list(align = "center", enabled = TRUE,
                          style = list(
                                      fontWeight = "bold",
                                      color = "#f7a35c",
                                      textOutline = NULL
                                      )
                          ),
        name = 'Segmentos'
    ) %>%
    hc_xAxis(categories = unique(freqTable$Segment)) %>%
    hc_yAxis(title = list(text = "Número de clientes"))
```

Os clientes no segmento Campeões são considerados os mais valiosos e os Prestes a hibernar e Precisa de atenção, precisam de alguma atenção especial para os resgatar.


```{r,  include=FALSE}
# Base de dados para a classificação
setwd("C:/Users/Administrador/Downloads/ifood-data-business-analyst-test-master") # Trocar o caminho
dados <- read.csv(file = 'ml_project1_data.csv')

# Retirando algumas variaveis
dados$Z_CostContact = NULL
dados$Z_Revenue = NULL
dados$Dt_Customer = NULL

# Retirando o NA da variavel income
dados <- dados[!is.na(dados$Income),]

# Dando uma olhada nos dados
summary(dados)
str(dados)
```


```{r, include=FALSE}
# Transformando atributos categoricos, para poder usar  o algoritmo de machine learning
table(dados$Education)
unique(dados$Education)
dados$Education <- factor(dados$Education, levels = c('2n Cycle','Basic', 'Graduation', 'Master', 'PhD'), labels = c(1,2,3,4,5))
dados[is.na(dados$Education)]


table(dados$Marital_Status)
unique(dados$Marital_Status)
dados$Marital_Status <- factor(dados$Marital_Status, levels = c('Single','Together', 'Married', 'Divorced', 'Widow', 'Alone', 'Absurd', 'YOLO'), 
                               labels = c(1,2,3,4,5,6,7,8))
dados[is.na(dados$Marital_Status)]

# Transformando a variavel de interesse em fator 
dados$Response <- as.factor(as.numeric(dados$Response))
```


```{r, include=FALSE}
# Escalonamento atributos numéricos
dados [ , 2] = scale(dados [ , 2])
dados [ , 5:25] = scale(dados[ , 5:25])
```

```{r, include=FALSE}
# Dividindo a base em treinamento e teste
set.seed(1)
# 75% porque o banco de dados não é tao grande
divisao = sample.split(dados$Response, SplitRatio = 0.75) # os valores false não compoem os 75%

base_treinamento = subset(dados[-1], divisao == TRUE) 
base_teste = subset(dados[-1], divisao == FALSE) 
```

# Aplicando o algoritmo Naive Bayes

```{r, include=FALSE}
classificador = naiveBayes(x = base_treinamento[-24], y = base_treinamento$Response)
previsoes = predict(classificador, newdata = base_teste[-24])
```

Escolhi o algoritmo de Naive Bayes, pois ele desconsidera correlações entre as variáveis, tratando cada variável de forma independente. Este algoritmo também é mais rápido para implementar do que por exemplo um algoritmo SVM e além de não precisar de muitos dados para fazer a classificação.

# Matriz de confusão

```{r}
# matriz confusao compara a base de teste com as previsoes
matriz_confusao = table(base_teste[, 25], previsoes)

# Percentual acertos
confusionMatrix(matriz_confusao)
```

Analisando a matriz de confusâo, na classe 0 (cliente não comprou a oferta) o algoritmo classificou corretamente 449 observações e incorretamente 22 observações, na classe 1 (cliente comprou a oferta) o algoritmo classificou corretamente 67 observações e incorretamente 16 observações. Nas duas classes o algoritmo acertou mais do que errou.

O percentual de acerto do modelo foi de 93,14%.

# Fazendo previsões

```{r, include=FALSE}
dados$previsoes <- NULL
dados$previsoes <- previsoes
```

```{r}
dados[, -c(2:25)] %>% 
    head(28) %>% 
   pander()
```

Dos 30 primeiros ID (clientes), 24 foram classificados de forma correta e 6 de forma incorreta.